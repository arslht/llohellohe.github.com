#### Watcher优势
通过watcher，可以避免主动轮询导致的额外负担，更加实时和有效率。

eg.主节点设置临时节点主节点锁，备份主节点在这注册一个监视点。

主节点崩溃-》主节点锁被删除-》通知所有备份主节点-》选出新主节点

客户端设置的每个监视点与会话关联，监视点可以跨越不同服务端的连接而保持

#### Watcher接口

仅有一个接口：

	public void process(WatchedEvent event)
	

WatchedEvent代表watcher到的事件，它包含发生了什么事件，ZooKeeper的当前连接状态以及产生事件的ZNode路径。

1.	KeeperState
2.	EventType
3.	path

KeeperState包含Disconnected\SyncConnected\AuthFailed\ConnectedReadOnly\SaslAuthenticated\Expired等6种状态。


EventType包含五种状态：
                                  设置监视点
1.	None                      
2.	NodeCreated              exists
3.	NodeDeleted              exists,getDate 
4.	NodeDataChanged          exists,getDate 
5.	NodeChildrenChanged      getChildren 

其中后四种用于表示ZNode的状态或者数据变更，而None则用于会话的状态变更。

getData调用有两种方式设置监视点：
```
public byte[] getData(final String path, Watcher watcher, Stat stat); // 新的对象
public byte[] getData(String path, boolean watcher, Stat stat); // 使用默认的监视点
```
##### EventType为None的Watch
[SessionWatch实例](https://github.com/llohellohe/zookeeper/blob/master/src/main/java/yangqi/zookeeper/example/masterworker/SessionWatch.java)描述了，初始化一个ZooKeeper实例时注册的Watcher接口。

将在连接时收到EventType为None,KeeperState为SyncConnected,path为null的Event。


将在失去连接时收到EventType为None,KeeperState为:Disconnected,path为null的Event。

##### ChildrenCallback
通过getChildren方法，可以设置ChildrenCallback，以便获得获得当子节点发生变化时的相关信息。

ChildrenCallback 的唯一接口：

	 public void processResult(int rc, String path, Object ctx, List<String> children)

getChildren可以设置对应的Watcher,一旦发现节点的事件类型为NodeChildrenChanged后，可以继续设置watch。


[ChildrenCallbackMonitor实例](https://github.com/llohellohe/zookeeper/blob/master/src/main/java/yangqi/zookeeper/example/masterworker/ChildrenCallbackMonitor.java)

#### 普遍模型

1. 进行异步调用
2. 实现回调对象，并传入异步调用函数（Callback）中
3. 设置监视点，实现一个Watcher对象，传入Callback

#### 主从模型

**管理权变化** 设置主要主节点监视点（判断选举）
![](C:\Users\lht\Desktop\other\zk\4.1.png)

**主节点等待从节点列表的变化** 使用getChildren获取从节点列表并监视，使用本地缓存检查变化

#### multiop

#### 监视点代替显式缓存管理

#### 顺序的保障

#### 监视点的羊群效应和可扩展性
