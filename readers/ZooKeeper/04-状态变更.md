#### Watcher优势
通过watcher，可以避免主动轮询导致的额外负担，更加实时和有效率。

eg.主节点设置临时节点主节点锁，备份主节点在这注册一个监视点。

主节点崩溃-》主节点锁被删除-》通知所有备份主节点-》选出新主节点

客户端设置的每个监视点与会话关联，监视点可以跨越不同服务端的连接而保持

#### Watcher接口

仅有一个接口：

	public void process(WatchedEvent event)
	

WatchedEvent代表watcher到的事件，它包含发生了什么事件，ZooKeeper的当前连接状态以及产生事件的ZNode路径。

1.	KeeperState
2.	EventType
3.	path

KeeperState包含Disconnected\SyncConnected\AuthFailed\ConnectedReadOnly\SaslAuthenticated\Expired等6种状态。


EventType包含五种状态：
                                  设置监视点
1.	None                      
2.	NodeCreated              exists
3.	NodeDeleted              exists,getDate 
4.	NodeDataChanged          exists,getDate 
5.	NodeChildrenChanged      getChildren 

其中后四种用于表示ZNode的状态或者数据变更，而None则用于会话的状态变更。

getData调用有两种方式设置监视点：
```
public byte[] getData(final String path, Watcher watcher, Stat stat); // 新的对象
public byte[] getData(String path, boolean watcher, Stat stat); // 使用默认的监视点
```
##### EventType为None的Watch
[SessionWatch实例](https://github.com/llohellohe/zookeeper/blob/master/src/main/java/yangqi/zookeeper/example/masterworker/SessionWatch.java)描述了，初始化一个ZooKeeper实例时注册的Watcher接口。

将在连接时收到EventType为None,KeeperState为SyncConnected,path为null的Event。


将在失去连接时收到EventType为None,KeeperState为:Disconnected,path为null的Event。

##### ChildrenCallback
通过getChildren方法，可以设置ChildrenCallback，以便获得获得当子节点发生变化时的相关信息。

ChildrenCallback 的唯一接口：

	 public void processResult(int rc, String path, Object ctx, List<String> children)

getChildren可以设置对应的Watcher,一旦发现节点的事件类型为NodeChildrenChanged后，可以继续设置watch。


[ChildrenCallbackMonitor实例](https://github.com/llohellohe/zookeeper/blob/master/src/main/java/yangqi/zookeeper/example/masterworker/ChildrenCallbackMonitor.java)

#### 普遍模型

1. 进行异步调用
2. 实现回调对象，并传入异步调用函数（Callback）中
3. 设置监视点，实现一个Watcher对象，传入Callback

#### 主从模型

1. 管理权变化 

设置主要主节点监视点（判断选举）

![主节点竞选中可能的交错操作](https://github.com/arslht/zookeeper/blob/master/4.1.png)

2. 主节点等待从节点列表的变化 

使用getChildren获取从节点列表并监视，使用本地缓存检查变化

3. 主节点等待新任务进行分配

主节点成功分配任务后，会删除/tasks节点下对应的任务

4. 从节点等待分配新任务

当我们与服务端的连接断开时（eg. CONNECTIONLOSS），直到连接重新建立前，不会传送任何监视点

5. 客户端等待任务的执行结果

从节点执行一个任务时，会在/status下创建一个znode节点

创建有序节点时发生CONNECTIONLOSS如何确认是否创建成功

#### multiop

原子性的执行多个zookeeper操作

transaction（事物）封装了multi方法

检查一个znode节点的版本（Op check）

#### 监视点代替显式缓存管理

客户端本地缓存数据

注册监视点接收通知、更新缓存

#### 顺序的保障

###### 写操作的顺序

###### 读操作的顺序

隐藏通道场景：
	- 客户端c1更新了/z节点的数据，并收到应答
	- c1通过tcp直连告知c2，/z节点状态变化
	- c2读取/z节点状态，但是在c1更新之前就观察到了
	
###### 通知的顺序

活性与安全性

#### 监视点的羊群效应和可扩展性

避免在一个特定节点设置大量的监视点

同时注意设置的监视点数量 （250~300字节内存/一个监视点）
